# Westworld of Warcraft (WWoW) - Architecture Overview

This document provides a high-level architectural overview of the WWoW (Westworld of Warcraft) system, intended to help GitHub Copilot and developers quickly understand the codebase structure and design patterns.

## System Purpose

WWoW is a simulation platform that transforms a World of Warcraft–like server into a living world populated by AI-driven bots. The system aims to create AI-controlled characters indistinguishable from human players in behavior, serving as a testbed for agent-based AI research in complex game environments.

## Solution Architecture

```
???????????????????????????????????????????????????????????????????????????????
?                              WWoW System                                     ?
???????????????????????????????????????????????????????????????????????????????
?  ???????????????????  ???????????????????  ???????????????????????????????  ?
?  ?   UI Layer      ?  ?  Services Layer ?  ?    Native Exports Layer     ?  ?
?  ?                 ?  ?                 ?  ?                             ?  ?
?  ? • StateManagerUI?  ? • PathfindingS. ?  ? • Loader (C++ DLL)          ?  ?
?  ? • AppHost       ?  ? • StateManager  ?  ? • FastCall (C++ DLL)        ?  ?
?  ? (Aspire)        ?  ? • DecisionEng.  ?  ? • Navigation (C++ DLL)      ?  ?
?  ?                 ?  ? • PromptHandler ?  ?                             ?  ?
?  ?                 ?  ? • ForegroundBot ?  ?                             ?  ?
?  ?                 ?  ? • BackgroundBot ?  ?                             ?  ?
?  ???????????????????  ???????????????????  ???????????????????????????????  ?
?           ?                    ?                          ?                  ?
?           ?????????????????????????????????????????????????                  ?
?                                ?                                             ?
?  ?????????????????????????????????????????????????????????????????????????  ?
?  ?                         Exports Layer (Core Libraries)                 ?  ?
?  ?                                                                        ?  ?
?  ?  ????????????????  ?????????????????  ????????????????  ????????????? ?  ?
?  ?  ?  BotRunner   ?  ? WoWSharpClient?  ? BotCommLayer ?  ?GameData   ? ?  ?
?  ?  ?              ?  ?               ?  ?              ?  ?.Core      ? ?  ?
?  ?  ? Bot Service  ?  ? WoW Protocol  ?  ? Protobuf IPC ?  ?Interfaces ? ?  ?
?  ?  ? Orchestration?  ? Implementation?  ? Socket Comm  ?  ?& Enums    ? ?  ?
?  ?  ????????????????  ?????????????????  ????????????????  ????????????? ?  ?
?  ?                                                                        ?  ?
?  ?  ????????????????????                                                  ?  ?
?  ?  ? WinProcessImports?  Low-level Windows API interop                   ?  ?
?  ?  ????????????????????                                                  ?  ?
?  ??????????????????????????????????????????????????????????????????????????  ?
?                                                                              ?
?  ????????????????????????????????????????????????????????????????????????????
?  ?                           BloogBot.AI Module                            ??
?  ?  • Semantic Kernel integration                                          ??
?  ?  • State machine (Stateless library)                                    ??
?  ?  • Activity-based AI coordination                                       ??
?  ????????????????????????????????????????????????????????????????????????????
???????????????????????????????????????????????????????????????????????????????
```

## Dependency Inversion Principles

The architecture follows strict dependency rules to maintain clean separation of concerns:

```
???????????????????????????????????????????????????????????????????????????
?                        Dependency Flow (Top to Bottom)                  ?
?                                                                         ?
?   GameData.Core (Foundation - NO project dependencies)                  ?
?         ?                                                               ?
?   BotCommLayer (IPC Layer - can depend on GameData.Core)                ?
?         ?                                                               ?
?   BotRunner (Core Logic - depends on GameData.Core)                     ?
?         ?                                                               ?
?   WoWSharpClient (Protocol - depends on GameData.Core, BotCommLayer,    ?
?                   BotRunner)                                            ?
?         ?                                                               ?
?   Services (depends on lower layers as needed)                          ?
?         ?                                                               ?
?   UI (depends on services and exports)                                  ?
???????????????????????????????????????????????????????????????????????????
```

### Key Rules

1. **GameData.Core** - The foundation layer containing interfaces and models. Must have NO project dependencies (only NuGet packages like Newtonsoft.Json for serialization).

2. **BotCommLayer** - IPC messaging layer. Can depend only on GameData.Core for shared types.

3. **BotRunner** - Core bot logic. Can depend on GameData.Core and use BotCommLayer types.

4. **WoWSharpClient** - Protocol implementation. Can depend on any Export layer project.

5. **Services** - Background workers. Can depend on any Export layer project.

6. **UI** - User interfaces. Can depend on any layer below.

### Anti-Patterns to Avoid

- ? **Circular dependencies** - Never create dependency cycles between projects
- ? **Upward dependencies** - Lower layers must never reference higher layers
- ? **GameData.Core pollution** - Keep GameData.Core free of implementation dependencies

### Dependency Inversion Pattern (IActivitySnapshot)

The codebase uses the Dependency Inversion Principle for cross-layer communication:

**Problem**: `IObjectManager` needed to use `ActivitySnapshot` (a Protobuf type from BotCommLayer), but GameData.Core should not depend on BotCommLayer.

**Solution**:
1. `GameData.Core` defines `IActivitySnapshot` interface with the essential contract
2. `BotCommLayer` has `ActivitySnapshot` implement `IActivitySnapshot` via a partial class
3. `IObjectManager.UpdateSnapshot()` accepts `IActivitySnapshot` instead of the concrete type
4. GameData.Core has NO project dependencies (only NuGet packages)

**Dependency Flow**:
```
GameData.Core (defines IActivitySnapshot - NO project dependencies)
       ?
BotCommLayer (ActivitySnapshot implements IActivitySnapshot)
       ?
Services/UI (use ActivitySnapshot which satisfies IActivitySnapshot)
```

## Layer Descriptions

### 1. UI Layer (`/UI`)

**Purpose**: User interfaces and orchestration hosts.

| Project | Description |
|---------|-------------|
| `StateManagerUI` | WPF desktop application for monitoring and controlling bot state machines |
| `WWoW.Systems.AppHost` | .NET Aspire host for orchestrating containerized WoW server + services |
| `WWoW.Systems.ServiceDefaults` | Shared service configuration and defaults for Aspire |

### 2. Services Layer (`/Services`)

**Purpose**: Background workers and microservices that provide specific bot functionality.

| Service | Description | Type |
|---------|-------------|------|
| `PathfindingService` | A* pathfinding using Detour/Recast navmesh data | Worker Service |
| `StateManager` | Stack-based finite state machine for bot behavior coordination | Worker Service |
| `DecisionEngineService` | Rule-based decision processing with combat prediction | Worker Service |
| `PromptHandlingService` | Handles in-game dialog prompts and confirmations | Worker Service |
| `ForegroundBotRunner` | Injectable DLL service for in-process bot control via memory manipulation | Console Exe (Injected) |
| `BackgroundBotRunner` | Headless bot using WoWSharpClient protocol emulation | Worker Service (Library) |

> **See [BotRunner Architecture](#botrunner-architecture) for detailed information about the relationship between BotRunner and its implementations.**

### 3. Exports Layer (`/Exports`)

**Purpose**: Core libraries and native interop components shared across the solution.

| Project | Description | Language |
|---------|-------------|----------|
| `BotRunner` | **Core bot orchestration library** - behavior trees, pathfinding clients, game state coordination | C# |
| `WoWSharpClient` | Pure C# WoW protocol implementation (auth, world packets, object manager) for headless operation | C# |
| `BotCommLayer` | Protobuf-based socket communication for inter-process messaging | C# |
| `GameData.Core` | **Shared interfaces** (`IObjectManager`, `IWoWUnit`, etc.), enums, and models | C# |
| `WinProcessImports` | P/Invoke wrappers for Windows process manipulation | C# |
| `Loader` | CLR bootstrapper DLL injected into WoW process (used by ForegroundBotRunner) | C++ |
| `FastCall` | Helper for x86 fastcall convention function invocations (Vanilla client) | C++ |
| `Navigation` | Detour/Recast navmesh queries and physics simulation | C++ |

### 4. AI Module (`/BloogBot.AI`)

**Purpose**: Advanced AI coordination using modern .NET patterns.

- **Semantic Kernel Integration**: Plugin-based AI orchestration
- **State Machine**: Stateless library for activity state management
- **Activity System**: 25+ bot activities (Combat, Questing, Trading, etc.)
- **Trigger System**: Event-driven state transitions

### 5. Tests (`/Tests`)

Unit and integration tests for core components:
- `PathfindingService.Tests`
- `BotRunner.Tests`
- `PromptHandlingService.Tests`
- `WoWSharpClient.Tests`

## Key Design Patterns

### State Machine Pattern
The bot uses a **stack-based finite state machine** (`StateManager`). States are pushed/popped based on game conditions:
- Combat starts ? Push `CombatState`
- Enemy dies ? Pop `CombatState`, Push `LootState`
- Low health ? Push `RestState`
- Death ? Pop all, push recovery sequence

### Dependency Injection Pattern
Services use `IDependencyContainer` to inject:
- Game state factories
- Bot settings
- Hotspot configurations
- State creation delegates

### Event-Driven Architecture
- `SignalEventManager` captures WoW client events
- `PromptHandlingService` reacts to game prompts
- `WoWSharpClient` uses event handlers for packet processing

### Protocol Buffer Communication
`BotCommLayer` provides TCP socket-based inter-service communication:
- `ProtobufSocketServer<TRequest, TResponse>` - TCP server with length-prefixed Protobuf messages
- `ProtobufSocketClient<TRequest, TResponse>` - TCP client for service-to-service calls
- Thread-safe, synchronous request/response pattern

**Message Format**: `[4-byte length][Protobuf payload]`

```csharp
// Server (e.g., PathfindingService)
public class PathfindingSocketServer : ProtobufSocketServer<PathfindingRequest, PathfindingResponse>
{
    protected override PathfindingResponse HandleRequest(PathfindingRequest request) { /* ... */ }
}

// Client (e.g., BotRunner calling PathfindingService)
var client = new PathfindingClient(ipAddress, port, logger);
var response = client.SendMessage(request);
```

**Service Communication Map**:
```
BackgroundBotRunner ??? PathfindingService (paths, physics)
BackgroundBotRunner ??? StateManager (character state sync)
DecisionEngineService ??? CombatModelClient (ML predictions)
```

## Supported WoW Versions

| Version | Build | Codename |
|---------|-------|----------|
| 1.12.1 | 5875 | Vanilla |
| 2.4.3 | 8606 | TBC |
| 3.3.5a | 12340 | WotLK |

## Data Flow

```
Game Client ???????????????????????????????????????????????????????????????????
     ?                                                                        ?
     ? Memory Read/Write                                                      ?
     ?                                                                        ?
???????????????    Packets     ???????????????????    State Updates          ?
? Loader.dll  ?????????????????? WoWSharpClient  ???????????????????????     ?
? (Injected)  ?                ? (Protocol Impl) ?                     ?     ?
???????????????                ???????????????????                     ?     ?
                                                                       ?     ?
???????????????????          ???????????????????         ?????????????????? ?
?PathfindingService???????????  StateManager   ??????????? DecisionEngine ? ?
?  (A* + Navmesh) ?  Paths   ? (FSM Brain)     ? Decisions?  (Rules/AI)   ? ?
???????????????????          ???????????????????         ?????????????????? ?
         ?                            ?                                      ?
         ?                            ? Commands                             ?
         ?????????????????????????????????????????????????????????????????????
                                      ?
                                      ?
                           ???????????????????????
                           ?   Game Actions      ?
                           ? (Move, Cast, Loot)  ?
                           ???????????????????????
```

## Technology Stack

| Component | Technology |
|-----------|------------|
| Runtime | .NET 8.0 |
| UI Framework | WPF (Windows) |
| Orchestration | .NET Aspire |
| State Machine | Stateless library |
| AI/ML | Microsoft Semantic Kernel |
| Serialization | Protobuf-net |
| Database | SQLite / SQL Server |
| Native Code | C++ (MSVC) |
| Navigation | Detour/Recast |
| Build System | MSBuild / Visual Studio 2022 |

## Configuration Files

| File | Purpose |
|------|---------|
| `bootstrapperSettings.json` | WoW client path, injection settings |
| `botSettings.json` | Bot behavior, hotspots, kill-switches |
| `appsettings.json` | Service-specific configuration |

## BotRunner Architecture

The bot system uses a **strategy pattern** where `BotRunner` provides core orchestration logic, and two different implementations provide the `IObjectManager` interface for interacting with the game world.

```
???????????????????????????????????????????????????????????????????????????????
?                          BotRunner (Core Library)                           ?
?                                                                             ?
?  • BotRunnerService - Behavior tree execution, state coordination           ?
?  • PathfindingClient - Requests paths from PathfindingService               ?
?  • CharacterStateUpdateClient - Syncs state with StateManager               ?
?  • Depends on: GameData.Core (IObjectManager interface)                     ?
???????????????????????????????????????????????????????????????????????????????
                                      ?
                    ?????????????????????????????????????
                    ?                                   ?
    ?????????????????????????????????   ?????????????????????????????????
    ?     ForegroundBotRunner       ?   ?      BackgroundBotRunner      ?
    ?      (DLL Injection)          ?   ?    (Headless/Emulated)        ?
    ?????????????????????????????????   ?????????????????????????????????
    ? • Injected into WoW.exe       ?   ? • Standalone .NET process     ?
    ? • Direct memory read/write    ?   ? • WoWSharpClient protocol     ?
    ? • Lua script execution        ?   ? • Network packet emulation    ?
    ? • Native function calls       ?   ? • No game client required     ?
    ? • Uses: Loader.dll, FastCall  ?   ? • Uses: WoWSharpObjectManager ?
    ? • ObjectManager (in-process)  ?   ? • BackgroundService pattern   ?
    ?????????????????????????????????   ?????????????????????????????????
```

### ForegroundBotRunner (In-Process / DLL Injection)

**Purpose**: Operates inside the WoW game client process via DLL injection.

**Key Characteristics**:
- Injected by `Loader.dll` (C++ CLR bootstrapper)
- Implements `IObjectManager` via direct memory access (`MemoryManager`, `Functions`)
- Uses `FastCall.dll` for x86 calling convention interop (Vanilla client)
- Can execute Lua scripts and call WoW internal functions
- Requires a running WoW game client
- Single bot per game instance

**Use Cases**:
- Development and debugging with visual feedback
- Testing bot behavior in a real game environment
- Scenarios requiring game UI interaction

### BackgroundBotRunner (Headless / Protocol Emulation)

**Purpose**: Operates without a game client by emulating the WoW protocol.

**Key Characteristics**:
- Uses `WoWSharpClient` for auth/world server communication
- Implements `IObjectManager` via `WoWSharpObjectManager` (packet-based state)
- Runs as a .NET `BackgroundService` (Worker Service pattern)
- No game client installation required
- Supports multiple concurrent bots per machine
- Integrates with `PromptHandlingService` for dialog automation

**Use Cases**:
- Server-side bot farms with many concurrent bots
- CI/CD testing of bot logic without game clients
- Resource-efficient operation (no GPU/rendering overhead)
- Headless simulation environments

### Shared Components

Both implementations share:
- **`BotRunnerService`**: Core behavior tree execution and coordination
- **`PathfindingClient`**: Requests navigation paths from `PathfindingService`
- **`CharacterStateUpdateClient`**: Synchronizes state with `StateManager`
- **`GameData.Core`**: All interfaces (`IObjectManager`, `IWoWUnit`, etc.) and models

> **See [PROJECT_STRUCTURE.md](PROJECT_STRUCTURE.md) for detailed file layouts.**
> **See [DEVELOPMENT_GUIDE.md](DEVELOPMENT_GUIDE.md) for implementation guidance.**
> **See [.github/COPILOT_CONTEXT.md](.github/COPILOT_CONTEXT.md) for quick Copilot reference.**

## Navigation & Physics System

The `Navigation.dll` provides both A* pathfinding and a PhysX-style physics simulation for character movement.

> **See [docs/physics/README.md](docs/physics/README.md) for detailed physics system documentation.**

### PathfindingService Integration

```
????????????????????????      Protobuf/TCP       ???????????????????????
?   BotRunner /        ? ???????????????????????? ?  PathfindingService ?
?   WoWSharpClient     ?   PathfindingRequest    ?                     ?
?                      ?   PathfindingResponse   ?  ?????????????????  ?
?  PathfindingClient   ?                         ?  ? Navigation.dll?  ?
????????????????????????                         ?  ?  (P/Invoke)   ?  ?
                                                 ?  ?????????????????  ?
                                                 ???????????????????????
```

**Request Types** (via `PathfindingRequest` oneof):
- `CalculatePathRequest` ? A* path from start to end position
- `LineOfSightRequest` ? Ray cast for visibility check
- `PhysicsInput` ? Full physics step simulation (StepV2)

### Physics Constants (`PhysicsTolerances.h`)

| Constant | Value | Description |
|----------|-------|-------------|
| `STEP_HEIGHT` | 0.6f | Max height for auto-stepping (stairs) |
| `STEP_DOWN_HEIGHT` | 0.5f | Max drop for ground snap |
| `GRAVITY` | 19.29f | WoW gravity (yards/s²) |
| `JUMP_VELOCITY` | 7.96f | Initial jump velocity |
| `DEFAULT_WALKABLE_MIN_NORMAL_Z` | 0.5f | ~60° max walkable slope |
| `WATER_LEVEL_DELTA` | 1.0f | Swim threshold below water surface |

### Key Physics Concepts

**Three-Pass Movement** (PhysX CCT pattern):
1. **UP Pass**: Lift character by step offset to clear small obstacles
2. **SIDE Pass**: Horizontal collide-and-slide against walls
3. **DOWN Pass**: Snap back to ground, validating slope walkability

**Collide-and-Slide**: Iterative algorithm that projects movement onto contact surfaces when hitting walls, allowing smooth sliding along geometry.

**Ground Snap**: After horizontal movement, sweep downward to find walkable ground within `STEP_DOWN_HEIGHT`. Prevents floating above terrain.

## Future Architecture (Roadmap)

1. **Azure AI Foundry Integration**: Cloud-based agent management
2. **Microsoft Fabric**: Data pipeline for behavior analytics
3. **Conversational AI**: NLP integration for in-game chat
4. **Headless Simulation**: Scale BackgroundBotRunner for massive bot populations
