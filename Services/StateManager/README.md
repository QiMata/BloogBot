# StateManager Service

## Overview of the StateManager Service

The **StateManager** service is the core of BloogBot’s AI system. It implements a stack-based **finite state machine** to control bot behavior. This service tracks what the bot is currently doing (its “state”) and manages transitions between tasks like combat, traveling, resting, etc. At runtime, the StateManager continually updates the active state and pushes or pops states on a stack as conditions change. This design allows the bot to handle nested goals – for example, if the bot dies, a sequence of corpse-retrieval states can be pushed on the stack on top of the regular grinding state. When those interim states complete, the bot automatically returns to its previous state.

In the overall application, StateManager serves as the **brain of the bot’s automation**. It works closely with other systems (like navigation and combat logic) by coordinating their actions through defined states. The service also enforces safety “kill-switches” and notifies other components when certain events occur. For instance, the StateManager will stop the bot if it has been stuck in one state or one position for too long (to prevent endless loops) and can send an alert (via Discord integration) when that happens. It similarly monitors for unusual events (like the player teleporting) and triggers a stop and alert if detected, as long as those features are enabled in the configuration. Overall, StateManager ensures the bot operates autonomously, reacts to in-game events, and stays within defined safety parameters.

## Directory Structure and Components

The `/Services/StateManager` directory contains all the classes and modules related to the bot’s state-machine logic. Below is an outline of the structure, along with each component’s responsibility and how they interact:

* **State Manager Core (StateManager Class)** – The main orchestrator of the state machine. This class (often implemented as the base `Bot` class in the code) owns the **stack of states** and the primary logic for running and switching states. It maintains internal flags and timers to track the bot’s status (e.g. whether it’s running, when it entered the current state, last known position). Key methods include:

  * `Start(IDependencyContainer container, Action stopCallback)` – Begins a bot session. This initializes the state stack with a base state (usually the grinding/patrol state) and sets `running = true`. It then enters an update loop (on an async tick) that repeatedly calls the current state’s `Update()` method. On start, it also invokes any immediate transitions needed (for example, checking if the bot should travel to a hotspot before starting to grind).
  * `Stop()` – Stops the bot’s execution loop. This will set the run flag to false and clear out all states from the stack. The provided stop callback is called, allowing the rest of the system (UI or other services) to handle a stopped bot.
  * `Travel(IDependencyContainer container, bool reverse, Action callback)` – Temporarily overrides the normal state machine to navigate along a travel path. This is used to move the player to a specific location (for example, traveling to a town or between hotspots). Internally, this method pushes a specialized sequence of states onto the stack: it calculates the nearest waypoint and pushes a `TravelState` (to traverse a series of waypoints) and a `MoveToPositionState` (to move to the first waypoint). It sets a one-time callback so that when travel is complete, the bot stops or resumes as needed. Essentially, `Travel()` hands control to the StateManager to navigate the route, then calls the given callback when done.
  * `StartPowerlevel(IDependencyContainer container, Action stopCallback)` – Similar to `Start()`, but initiates a “power-leveling” mode. In this mode, the bot likely uses a `PowerlevelState` as its base state instead of the normal grinding state, altering behavior (for example, allowing a second character to leech experience). Under the hood this works analogously to a normal start, pushing a `PowerlevelState` on the stack and then running the update loop. The StateManager’s loop logic treats `PowerlevelState` interchangeably with the normal grind state for things like resetting errands or determining idle state.
  * **Internal update loop** – Once started, the StateManager enters a loop (`StartInternal`) that ticks every few milliseconds (50ms in this case). On each tick, it performs housekeeping and then updates the current state:

    * It checks for level-ups and other events, sending announcements if needed (e.g. a “Ding!” message when the player levels up).
    * It updates anti-AFK movement periodically to prevent the game from marking the player idle.
    * It runs various **kill-switch checks** based on the configuration: for example, if the player is flagged as possibly teleported, and teleport kill-switch is on, it sends an alert and stops the bot. If the bot has been stuck in one state too long (and the “stuck in state” kill-switch is enabled), it logs a help message and stops. Similarly, it checks if the bot stayed at the same coordinates too long (stuck in position) and stops if so.
    * It monitors the player’s status. If the player has died and is a ghost, the StateManager will initiate the death recovery routine (if not already doing so). It will **pop all current states except the base state** (clearing any ongoing combat or travel) and then push a sequence of states for corpse retrieval. In the death scenario, it pushes (in order) a Rest state (to heal after revival), then `RetrieveCorpseState` (to accept resurrection), then `MoveToCorpseState` (to navigate to the corpse), and `ReleaseCorpseState` (to release the spirit if not already) on the stack. These states are marked as “errands” (a flag to indicate the bot is off its normal routine) until the corpse is retrieved.
    * It also continuously evaluates conditions like equipment durability and inventory space. For example, if gear durability falls below a threshold and a repair vendor is defined at the current hotspot, the StateManager interrupts normal behavior to handle repairs. It will pop back to the base state, mark that it’s now doing errands, and then push a series of states to get repairs done. In this case, it may push a Travel path to the vendor (Travel + MoveToPosition states for the route) if a travel path is configured, then push a `RepairEquipmentState` followed by a `MoveToPositionState` to move into range of the repair NPC. After queuing those, it calls `CheckForTravelPath(..., true)` which can insert a return travel state if needed (i.e., if the bot traveled somewhere for errands, it can plan to travel back after).
    * Similarly, if the inventory is full and there is an innkeeper vendor (to sell items) at the hotspot, the StateManager will initiate a selling routine in the same fashion: pop to base, mark errands, push travel states (if a travel path exists) and then push `SellItemsState` plus a move-to-vendor state. After selling, it again invokes `CheckForTravelPath` to possibly return to the grind area.
    * Each tick, after handling those conditions, the StateManager finally calls `Update()` on the **top-of-stack state** (the active state). The `CurrentState` name is recorded (for debugging/monitoring) and the state’s logic executes one step. This update may in turn lead to pushing or popping states within the state’s own code (for example, a combat state might determine it should transition to a loot state when a mob dies, and push that on the stack).
    * The loop repeats until `running` is false. The run flag is turned off either when the bot stops normally (user or system called `Stop()`), or when a kill-switch condition triggers a stop, or when the bot finishes a one-time task (like completing a travel or power-level session triggers a stop callback).

* **State Interface (`IBotState`)** – The contract for any **state** in the system. A state represents a single behavior or mode (e.g. “Combat”, “Loot corpse”, “Travel to point”, “Resting”). The interface (in `IBotState.cs`) currently only requires one method: `void Update()`. Every concrete state class implements `Update()` with its behavior, which will be called repeatedly by the StateManager when that state is on top of the stack. The simplicity of `IBotState` makes it easy to implement new states. States often also have a constructor that takes references to relevant context (for example, many states take the `Stack<IBotState>` itself and a dependency container, plus perhaps a target object or coordinates). This allows states to interact with the stack (e.g. push new states) and query game info via the container.

* **Dependency Container (`IDependencyContainer`)** – This interface acts as a bridge between the StateManager and game-specific or bot-specific data/logic. The StateManager core is game-agnostic to some extent; it relies on `IDependencyContainer` to supply game-world information and to create new state instances when needed. Notable members of `IDependencyContainer` include:

  * **Factory Methods for States**: The container provides delegates used to instantiate certain common states specific to the current bot. For example, `CreateRestState`, `CreateMoveToTargetState`, and `CreatePowerlevelCombatState` are function properties that the bot sets up to point to its own state classes. This design means the StateManager can ask for a “Rest state” or “MoveToTarget state” without knowing the exact class – the active bot plugin will create the appropriate instance. (For instance, a mage bot might create a `RestState` that eats/drinks, whereas another bot might have a different rest behavior. By injecting the factory, the StateManager calls `container.CreateRestState(...)` to get an appropriate state object.)
  * **Bot Settings and Environment Data**: The container holds the loaded `BotSettings` (configuration values) and references to game world data like the list of `Hotspot`s (areas to grind) and a `Probe` for telemetry. The StateManager uses these to make decisions; for example, it calls `container.GetCurrentHotspot()` to know where the nearest vendor or travel path is, and it checks flags like `container.BotSettings.UseTeleportKillswitch` or `UseStuckInStateKillswitch` to decide whether to enforce certain kill-switches.
  * **Utility Methods**: The container interface defines methods that the StateManager or states can call, such as `FindClosestTarget()` or `UpdatePlayerTrackers()`, which encapsulate game-specific logic for finding enemies or updating status trackers. It also has `CheckForTravelPath(Stack<IBotState> states, bool reverse, bool needsToRest)` which the StateManager calls to automatically insert travel states if a travel path is needed when starting or finishing errands. The container may toggle internal flags like `RunningErrands` to inform the state logic whether the bot is in its normal routine or off doing an errand.

* **State Classes (Concrete States)** – These are the individual states that perform actions. They are found in the StateManager directory (often organized in subfolders, e.g. a `SharedStates` subfolder for generic states used by all bots). Each state class implements `IBotState` and typically corresponds to a specific repeated task or mode. Key state classes include:

  * *Base Grinding/Combat States*: **GrindState** is usually the base looping state for killing mobs in a hotspot (the default state pushed when the bot starts). **PowerlevelState** is a variant base state for power-level mode (likely having logic to follow another player or let them get kills). Combat for each class is handled by a specific Combat state (e.g. `FrostMageBot.CombatState`) which often inherits from a common **CombatStateBase** class in `SharedStates`. The `CombatStateBase` in the StateManager service provides shared combat utility (common targeting, movement, or rotation logic), and each bot’s `CombatState` extends it to implement class-specific attack routines. These states manage engaging a target: they may push other states like moving within range or casting spells as needed.
  * *Movement and Navigation States*: **MoveToTargetState** handles moving the character into combat range of a specific target unit (used when the bot has picked an enemy to attack). **MoveToPositionState** moves the bot to a specific `Position` or coordinate – this is a general movement used for various purposes (e.g., navigating to a vendor or a hotspot location). **TravelState** is used for long-distance movement across multiple waypoints; it encapsulates following a predetermined route (a **TravelPath**) comprised of waypoints. TravelState works in tandem with MoveToPositionState: typically the StateManager pushes a TravelState along with an initial MoveToPositionState pointing to the first waypoint, so that the bot moves from point to point until the path is complete.
  * *Resource Management States*: **RestState** causes the bot to pause and recover health/mana (e.g., eating or drinking). The StateManager will push a RestState in certain conditions, such as after resurrecting at a corpse or potentially when low on health and out of combat (depending on bot logic). **LootState** handles looting a corpse after a kill. **GatherObjectState** would handle interacting with a game object (like mining a node or opening a chest). These states generally run to completion quickly (e.g., loot one corpse then pop themselves off the stack).
  * *Vendor and Errand States*: These occur when the bot needs to resupply, sell, or repair. **RepairEquipmentState** will move to a repair NPC and perform equipment repairs. **SellItemsState** moves to a vendor to sell unwanted inventory items. There is also **BuyItemsState** (for buying consumables, etc.), and possibly states like **EquipArmorState** or **EquipBagsState** which equip newly acquired gear (these were present in the code base). The StateManager triggers these states based on conditions (durability low, bags full, etc.) and often groups them: for example, pushing both travel and vendor interaction states as a batch. Once the errand is done, the states will pop off and the bot resumes grinding.
  * *Death Recovery States*: As mentioned, **ReleaseCorpseState**, **MoveToCorpseState**, and **RetrieveCorpseState** are used in sequence when the player dies. `ReleaseCorpseState` handles releasing the spirit (if the player hasn’t auto-released), `MoveToCorpseState` pathfinds back to the corpse, and `RetrieveCorpseState` accepts the resurrection. After these, typically a RestState is also pushed to heal up before returning to normal activity.
  * *Miscellaneous States*: **StuckState** is a state invoked when the bot determines it’s stuck (perhaps via a stuck detection helper). It likely tries to move the character in some pattern to get unstuck. **PlayerTracker/FollowState** might exist to handle following a target (especially in powerlevel mode). There may also be states to handle special behaviors (e.g., a state for using a hearthstone or going to a specific waypoint).

Each state class focuses on a single responsibility. They often utilize game API helpers (from the `BloogBot.Game` namespace) to perform actions. For example, a combat state will use `ObjectManager` to find enemies and `Functions.CastSpell` or direct method calls to cast abilities. States can also push other states: e.g., a combat state might push a `LootState` when an enemy dies, or a grind state might push a move state when it needs to approach a target. States typically **do not pop themselves** directly (instead, the StateManager pops states when they finish or when higher priority states need to run). However, the StateManager base class provides a helper `PopStackToBaseState()` which some logic uses to clear out intermediate states when an overarching change happens (like starting an errand or responding to death).

* **Probe and Monitoring** – The StateManager works with a **Probe** object (found in the dependency container) to record runtime information. The Probe is updated each cycle with the name of the current state and the update loop latency (time taken per tick). This data can be used by the UI or debugging tools to display what the bot is doing and whether it’s running smoothly. For example, `container.Probe.CurrentState` will show “CombatState” or “LootState” etc., and `UpdateLatency` might show how many milliseconds each tick takes. This is especially useful for developers when tuning performance or diagnosing if the bot gets stuck.

In summary, the **StateManager** directory contains the core state machine logic (the manager itself, possibly named `StateManager` or realized as the `Bot` base class) and a library of state classes. The manager orchestrates switching between these states based on game conditions, while the individual state classes implement the specific actions. Together, these components allow BloogBot to autonomously grind, fight, travel, and handle game events in a modular way.

## Configuration and Usage Instructions

Using the StateManager service in development mainly involves configuring bot settings and invoking the appropriate start/stop methods. Below are instructions for developers or users to configure and interact with this service:

### Configuration via Bot Settings

The behavior of the StateManager is customizable through the **`botSettings.json`** configuration (loaded into the `BotSettings` object at runtime). Key settings in `BotSettings` that affect the StateManager include:

* **Kill-Switch Toggles**: Booleans such as `UseTeleportKillswitch`, `UseStuckInPositionKillswitch`, `UseStuckInStateKillswitch`, etc., control the safety mechanisms. If these are set to `true`, the StateManager will automatically stop the bot when it detects the corresponding condition (teleport, prolonged immobility, or being stuck in the same state too long). Developers should ensure these are appropriately set for the desired level of automation vs safety.
* **Current Bot and Travel Paths**: `CurrentBotName` selects which bot profile (class routine) to run. The StateManager uses `BotSettings.CurrentTravelPath` (an object linking to a TravelPath of waypoints) when executing travel errands. To use the travel features, you should configure a travel path for your hotspots or destinations. For example, if you want the bot to automatically run to town to sell, define a TravelPath in the data and set it on the current hotspot. The StateManager will then utilize it when needed.
* **Hotspot and Vendor Data**: The `GrindingHotspot` (and its ID) in settings determines where the bot grinds. Each hotspot can have associated vendor info (Innkeeper, RepairVendor, TravelPath). Make sure your hotspot data includes these if you want the bot to handle selling or repairing. The StateManager queries the **current hotspot’s** vendor and path info at runtime. For example, ensure `RepairVendor` is set for the hotspot so that the repair routine knows where to go.
* **Misc Options**: Other settings like `TargetingIncludedNames/ExcludedNames`, level ranges, creature types, etc., will influence which targets the bot fights (though these are more used by target selection logic than by the StateManager directly). However, they indirectly affect the states because, for instance, if no valid targets are found (due to settings), the bot might remain idling in a state.

Typically, developers will adjust these settings via the UI or config file rather than programmatically. The JSON is read on startup (for example, the `bootstrapperSettings.json` might specify which profile to load and `botSettings.json` holds the profile details). The StateManager service reads from `BotSettings` at runtime via the dependency container to respect these configurations.

### Starting and Stopping the Bot (Using the StateManager)

Developers interact with the StateManager primarily through the **IBot** interface implementation for each bot module. Under the hood, calling `IBot.Start()` or related methods invokes the StateManager’s logic as described. Here is how to use it:

1. **Obtain the Bot Instance** – Usually, you load a bot plugin via the `BotLoader` service, which uses MEF to find classes exported as `IBot`. Once you have your desired `IBot` object (e.g., an instance of `FrostMageBot` or `TestBot`), you can start it.

2. **Prepare Dependency Container** – Call `bot.GetDependencyContainer(botSettings, probe, hotspots)` to get an `IDependencyContainer` instance for this bot. The container will be configured with the bot’s specific factories and data:

   ```csharp
   IDependencyContainer container = myBot.GetDependencyContainer(currentBotSettings, probe, hotspots);
   ```

   This container includes the bot’s custom state creation delegates (for rest, movement, etc.) and holds references to game objects like the `Probe` and hotspots. For example, in the TestBot implementation, the `DependencyContainer` is constructed with lambdas for how to create a RestState, MoveToTargetState, etc., for that bot. (Usually you don’t need to manually modify these – just use the one provided by the bot.)

3. **Start the Bot** – Invoke `myBot.Start(container, stopCallback)`. The `stopCallback` is a method you provide that the StateManager will call once the bot stops (this could be used to update UI, etc.). When `Start` is called, the StateManager will push the initial state and begin its update loop. From this point on, the bot is running autonomously. You should see in the logs or UI that the bot has entered its first state (typically “GrindState” or similar).

   * **Concurrency**: Note that `Start` immediately schedules the state updates on the main game thread (using an internal mechanism, likely via `ThreadSynchronizer` to sync with the game client thread). The updates run asynchronously. This means `myBot.Start()` will start the process and return quickly; the bot logic then runs in the background tick until stopped.

4. **Monitor or Interact (optional)** – While the bot is running, you can query `container.Probe` for the current state name or latency, if needed for a UI display. The bot might also be sending Discord messages or logging to files if certain events occur (level-ups, stuck alerts). No additional calls are needed to progress the bot; it will move through states on its own. If you have integrated commands (e.g., via a Discord command handler or UI button), those can call methods like `Travel` or signal the bot in other ways. For example, if the user clicks “Go to Town” in a UI, you might call `myBot.Travel(container, false, OnArrivedCallback)` to instruct the StateManager to perform a travel sequence. The StateManager will handle pausing the normal routine, traveling, and then call your `OnArrivedCallback` when done. At that point, you could decide to resume the bot’s routine (by calling `myBot.Start` again if it was stopped after travel), etc.

5. **Stopping the Bot** – To gracefully stop, call `myBot.Stop()`. This will break the StateManager’s loop and clear the state stack immediately. Any pending or active state is discarded. The configured stop callback (from the Start call) will be invoked, so your system can update (for instance, marking the bot as not running in the UI). It’s recommended to use this method to stop rather than abruptly terminating the process, so that all cleanup (and notifications) occur properly. The StateManager will, for example, log the stop and ensure any open tasks are halted.

**Example:** Starting a bot and then issuing a travel command might look like:

```csharp
// Assume myBot is an IBot (e.g., loaded FrostMageBot) and we have BotSettings and Probe ready.
var container = myBot.GetDependencyContainer(botSettings, probe, hotspots);
myBot.Start(container, () => Console.WriteLine("Bot stopped."));

// ... later, issue a travel to the innkeeper:
myBot.Travel(container, reverse:false, () => {
    Console.WriteLine("Travel complete. Resuming grind.");
    myBot.Start(container, null);  // resume normal routine without a new stop callback
});
```

In the above example, calling `Travel` pushes travel-related states (travel path + move, then vendor interaction) and the StateManager will automatically stop the bot when the travel sequence is done (because in the Travel implementation, `running` is set to false at completion and the provided callback is invoked). We then resume the normal grind by calling `Start` again. In practice, the UI or higher-level service might coordinate these calls rather than doing it manually in code, but this illustrates usage.

### Additional Usage Notes

* **Single Active Bot**: BloogBot is generally designed to run one bot profile at a time. The StateManager service (especially if tied to a global update loop) assumes control of one bot’s state stack. If you attempt to run multiple bots simultaneously (e.g., two different class profiles), they would each have their own StateManager instance (one per IBot). Typically, the application architecture will ensure only one is running at once, or each on separate threads. Be mindful of this if extending to multi-bot scenarios.
* **Thread Requirements**: Many game API calls (movement, casting, etc.) need to run on the game’s main thread. The StateManager uses a helper (like `ThreadSynchronizer.RunOnMainThread`) internally when pushing initial states and during each tick to execute state updates on the correct thread. As a developer, you usually don’t need to invoke `ThreadSynchronizer` manually when writing states because the StateManager already wraps the `Update()` calls inside a main thread context. If you write any asynchronous code or tasks within a state, ensure you marshal any game-interaction back to the main thread similarly.
* **Configuration Changes**: If you change `BotSettings` on the fly (for example, toggling a kill-switch or changing the target level range from the UI while the bot is running), those changes will be seen by the StateManager on its next tick because it reads from `container.BotSettings` each time. This means you can live-tweak some behavior, but exercise caution – some changes (like switching the `CurrentTravelPath` or `RepairVendor` mid-run) might not take effect until the related state triggers again. In general, stop the bot before making major config changes, or ensure your changes align with what the StateManager is currently doing.

## Contributing and Extending the StateManager

If you are a developer looking to extend the StateManager service – either by adding new states, new bot logic, or modifying the state manager itself – here are some guidelines and conventions to follow:

* **Follow the Finite State Machine Pattern**: The design relies on a clear state machine with push/pop transitions. When adding new functionality, try to express it in terms of states and transitions rather than monolithic processes. For example, if you want to add a “go to mailbox and check mail” feature, implement it as a set of states (TravelToMailboxState, CheckMailState, maybe ReturnToGrindState) and have the StateManager trigger them under the right conditions (perhaps when bags are full of loot to mail). Resist the urge to manage long processes in a single state’s Update; breaking tasks into discrete states keeps the system modular and easier to debug.

* **State Implementation**: Create new state classes as needed, implementing `IBotState`. Place general-purpose states in the StateManager service (or its subfolder for shared states), and bot-specific states in that bot’s own module. All state classes should be named with a **`State` suffix** and belong to an appropriate namespace (e.g., `BloogBot.AI.SharedStates` or the specific bot’s namespace). The code base uses PascalCase for class names and typically internal classes for states (they don’t usually need public access outside the service or bot plugin). Ensure each state’s `Update()` is focused on a single responsibility. For instance, a LootState should only handle the loot logic then usually pop itself (or finish) once done, handing control back to whatever is beneath it on the stack.

* **Leverage Base Classes and Shared States**: To promote code reuse, consider using existing abstract/base states. The StateManager module provides some base classes like `CombatStateBase` (which contains common combat routines used by all combat states) and possibly others like `CombatStateBase` or utility classes (e.g. a base class for moving along waypoints). If you’re adding a new combat routine for a class, inherit from `CombatStateBase` instead of starting from scratch – this way you get shared logic (like target selection or basic combat checks) and only need to implement the specifics (spells or rotations) for that class. The same goes for other behaviors: use or extend shared states where possible (for example, many classes might use the same `RestState` logic to eat/drink, which is already implemented as a shared state).

* **Extend the Dependency Container Thoughtfully**: When your new state needs data or actions from the environment that aren’t provided, you might want to extend `IDependencyContainer`. For instance, if you add a `MailState` that needs to get the nearest mailbox, you could add a method like `FindClosestMailbox()` to `IDependencyContainer` and implement it in the concrete container (using game APIs). However, avoid bloating the container with highly specific methods if possible – try to use general patterns. Many times you can incorporate logic inside a state using existing container methods (like using `FindClosestTarget()` for a generic target-finding need). If you do add to the container interface, update all implementations (each bot plugin’s container and possibly a default container) to provide that functionality.

* **Adding a New Bot (Class Routine)**: To add a new bot (for a class or strategy not yet implemented), create a new project (or folder) similar to the existing ones (e.g. `PaladinBot`, `RogueBot`, etc.). Implement the `IBot` interface for your bot. Typically, you would derive from the base `Bot` class (to inherit the Start/Stop logic) and also implement `IBot` explicitly. In your class, provide the required properties (`Name`, `FileName`) and implement `GetDependencyContainer`. Use the provided `DependencyContainer` class (from the StateManager service) to construct a container with your bot’s targeting criteria and state creation delegates. This means setting up `CreateRestState`, `CreateMoveToTargetState`, etc., to point to your bot’s versions of those states (or to shared states if you don’t need a custom one). For example:

  ```csharp
  public IDependencyContainer GetDependencyContainer(BotSettings s, Probe p, IEnumerable<Hotspot> hotspots) =>
      new DependencyContainer(
          AdditionalTargetingCriteria,      // your function to filter targets (or just return true)
          CreateRestState,                  // e.g. (stack, cont) => new RestState(stack, cont)
          CreateMoveToTargetState,          // e.g. (stack, cont, target) => new MoveToTargetState(stack, cont, target)
          CreatePowerlevelCombatState,      // e.g. (stack, cont, mob, friend) => new PowerlevelCombatState(stack, cont, mob, friend)
          s, p, hotspots);
  ```

  Ensure your bot’s states (combat, etc.) are implemented. Often you can utilize many of the shared states and only write class-specific ones (e.g. a `CombatState` for your class, plus any unique states necessary for its mechanics). By following the pattern used in existing bots, your new bot will automatically integrate with the StateManager – the `BotLoader` will pick it up if you add the `[Export(typeof(IBot))]` attribute, and then the Start/Stop UI will control it like others.

* **Respect Threading Model in States**: Within your state `Update()` methods, be careful to perform any game client calls on the main thread. The StateManager already calls `Update()` on the main thread context, so you can usually call game methods (like movement or casting functions) directly. If you spin off tasks or use asynchronous operations inside a state, you must marshal back to the main thread for game actions (you can use `ThreadSynchronizer.RunOnMainThread` for that). Most states won’t need to do this if kept simple and synchronous in the Update loop.

* **Use Logging and Alerts for Debugging**: The StateManager has some built-in logging (e.g., `Logger.Log(e)` on exceptions, writing to a `StuckLog.txt` for stuck events). When developing new states or transitions, utilize the `Logger` to record any unexpected conditions. If your state encounters something critical (like it cannot find a required NPC), you might consider using `DiscordClientWrapper.SendMessage` to notify, similar to how the kill-switches do. However, avoid spamming – such messages should be reserved for important alerts. For routine debug info, stick to console or log file output.

* **Testing New States**: It’s wise to test new states in isolation if possible. You can create a simple bot that triggers your new state for testing. For example, if you made a `MailState`, you could temporarily modify a bot to push that state on Start (instead of GrindState) to see it in action. Once it behaves correctly, integrate it into the normal conditions (e.g., push MailState when inventory has certain items or on a schedule). Always test states both as part of the stack and when they are interrupted by higher-priority states (for example, what happens if your state is active when the bot dies or an errand kicks in?). The StateManager’s design will pop it if needed, but your state should handle being terminated at any point without persistent side effects.

* **Maintain Consistency**: Follow the naming and coding conventions of the existing code. Keep methods and state transitions consistent with how others are done, so future maintainers can easily understand your additions. For instance, if adding a new kill-switch condition, name the config similarly (e.g., `UseXYZKillswitch`), check it in the update loop analogous to the existing ones, and include a similar alert/stop mechanism. Document any new config in the README or docs for the project.

By adhering to these guidelines, you can extend the StateManager service’s capabilities without introducing regressions. The StateManager is a central part of BloogBot’s architecture – changes here affect all bot behaviors – so any modifications should be carefully reviewed and tested. With well-designed states and thoughtful integration, the StateManager service can be expanded to handle new game mechanics or bot behaviors while remaining robust and manageable.
