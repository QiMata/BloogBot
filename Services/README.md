# Services Directory Overview

The `/Services` directory contains the major components of the BloogBot system, each encapsulated as a separate service or executable. These services allow BloogBot to run in different modes (interactive foreground or headless background) and to integrate advanced features like AI-based prompt handling. All service projects target .NET 8.0 and are configured to output their binaries into a common `Bot` folder for unified deployment. Below is an overview of each service component, including its purpose, how to run or test it, and its key dependencies.

## ForegroundBotRunner

**Purpose:** The ForegroundBotRunner is a console application (OutputType **Exe**) designed to launch and run a WoW bot in a live game client session. This is the traditional mode where a WoW client is running in the foreground, and the bot attaches to it and controls it in real-time.

**Usage:** To run the ForegroundBotRunner, open or attach to a WoW client (logged into the game) and then execute the `ForegroundBotRunner` program (e.g., via Visual Studio or by running the compiled executable from the `Bot` output directory). The service will inject into the WoW process and start the bot routine using the settings provided (e.g. in configuration files like `botSettings.json` and `bootstrapperSettings.json`). For testing, you can use a known bot profile (for example, the included `TestBot`) and observe the bot’s behavior in-game. Ensure you have the necessary config files in place in the `Bot` folder, as the ForegroundBotRunner will read those at startup.

**Dependencies:** This service relies on the core bot logic provided by the **BotRunner** library and game data definitions from **GameData.Core**. It also includes native hooking/injection components to manipulate the game process – notably **Fasm.NET** and **FastCall** are bundled as resource DLLs. These allow the bot to execute in-game actions by injecting assembly code into WoW’s memory. The ForegroundBotRunner does *not* depend on the other services (it does not use the PromptHandling service), and runs standalone for a single bot instance with a visible game client.

## BackgroundBotRunner

**Purpose:** The BackgroundBotRunner is a background worker service intended to run bots without an active UI, enabling headless or multi-instance bot operation. Unlike the foreground runner, this component can run bots in a non-interactive environment (for example, on a server or in the background of a machine) and is suited for automation scenarios. It’s implemented as a .NET Worker service (SDK `Microsoft.NET.Sdk.Worker`) built as a **class library** (OutputType Library), meaning it is designed to be hosted by a separate process (e.g. a Windows Service or a console host) rather than run on its own.

**Usage:** To use the BackgroundBotRunner, you need to host it within a .NET Generic Host or similar environment. In practice, this means writing a small bootstrap (if one is not already provided) that adds the BackgroundBotRunner service into a host and runs it. For example, a custom `Program` could create a host builder, add the BackgroundBotRunner as a hosted service, and run as a Windows Service or console app. Once running, the BackgroundBotRunner will manage the bot lifecycle in the background. For testing or development, you can create a simple console application to invoke this service: register the BackgroundBotRunner’s implementation with `Host.CreateDefaultBuilder`, then run the host to simulate the service’s behavior in a controlled environment. (Ensure that any necessary configuration or game client access is set up for the background session. In some cases, running WoW in the background may require a virtual display or appropriate OS settings since WoW is normally a GUI application.)

**Dependencies:** The BackgroundBotRunner depends on several other components of the system. It uses the **BotRunner** library for core bot behavior (behavior trees, state machines, etc.), and the **WoWSharpClient** library to interface with the WoW game process in a headless manner (WoWSharpClient likely contains the logic for memory reading/writing or remote procedure calls into WoW). The BackgroundBotRunner also **integrates the PromptHandlingService** – it references and invokes this service to handle any AI-driven commands or responses (see PromptHandlingService below). Like the foreground runner, it indirectly uses the BotComm layer and game data libraries via those dependencies. The BackgroundBotRunner is intended to run concurrently with the PromptHandlingService in the same host process (it does not directly produce an executable on its own). It does not depend on ForegroundBotRunner at all – instead, it offers an alternative mode of operation.

## PromptHandlingService

**Purpose:** The PromptHandlingService is an auxiliary service that introduces AI and natural-language capabilities to BloogBot. It is responsible for handling textual prompts or commands (for example, instructions from a user or higher-level AI directives) and translating them into bot actions or replies. This service allows integration with Large Language Models (LLMs) and other AI tools – enabling features like conversational bot commands or AI-generated decision-making.

**Usage:** The PromptHandlingService runs as a background component **alongside the BackgroundBotRunner**. It’s implemented as a .NET Worker library (OutputType Library) similar to the background runner. In practice, you don’t run this service by itself; it is loaded into the host process that is running the background bot. When the BackgroundBotRunner requires interpretation of a prompt or needs to produce a response (e.g., a user asks the bot a question or gives a high-level instruction), it will call into this service. For testing this component in isolation, developers can simulate prompt inputs by calling its methods or writing unit tests. For example, you might feed a sample command or question to the PromptHandlingService (with proper configuration for AI access) and verify that it returns a reasonable action or output. Note that to fully test its capabilities, you’ll need access to the configured AI services (e.g., a valid Azure OpenAI API key or a running Ollama server for local models, as required by its settings).

**Dependencies:** This service is heavy on external and internal integrations. On the external side, it uses the **Azure.AI.OpenAI** SDK and **OllamaSharp** library for connecting to AI models – this means it can query OpenAI’s services (or a local LLM via Ollama) to generate responses or parse instructions. It also includes **SQLite** via `sqlite-net-pcl`, suggesting it maintains a local database (perhaps for storing conversation history, game state context, or predefined prompt-response mappings). On the internal side, PromptHandlingService relies on the bot communication layer: it references **BotCommLayer** to send or receive data from the bot/game environment. This allows the service to, for example, fetch game state needed to inform the AI, or to dispatch AI-generated commands back to the running bot. The PromptHandlingService is utilized by the BackgroundBotRunner (which calls it as needed); it does not interact with the ForegroundBotRunner at all. In summary, its role is modular – it can be thought of as an optional AI-powered module that extends the background bot’s functionality with natural language understanding and decision support.

## Service Interactions and Dependencies

The services in this directory are designed to work in a complementary fashion, although each addresses a different use case:

* **Foreground vs Background:** The ForegroundBotRunner and BackgroundBotRunner are two separate execution modes for the bot. They do not depend on each other and are not run together – you will choose one or the other depending on your scenario. ForegroundBotRunner is self-contained for a single bot with a visible game client, whereas BackgroundBotRunner is meant for headless or automated operation (potentially enabling multiple bots or running without a user’s direct supervision). Both share the **BotRunner** core library for bot logic, and both ultimately rely on the same underlying game interaction layer (BotComm/WoWSharp), but they instantiate and use these in different contexts.

* **BackgroundBotRunner & PromptHandlingService:** These two have a close relationship. The PromptHandlingService is essentially an extension of the background bot service – the BackgroundBotRunner references it and invokes it to handle AI prompt processing. They are expected to run within the same host process, where PromptHandlingService operates as a background task/worker that the bot can call into. In terms of deployment, if you enable the background mode with AI features, you would host both of these together. The dependency is one-directional: BackgroundBotRunner depends on PromptHandlingService (for enhanced functionality), but the PromptHandlingService on its own doesn’t require the background runner except as a source of prompts.

* **Shared Libraries:** All services depend on a set of common libraries (found in the `/Exports` directory and elsewhere). For example, the BotRunner library provides the behavior tree engine and bot state management used by both Foreground and Background runners, and the BotCommLayer (with possibly a gRPC/Protobuf infrastructure) underpins communication with the game for all modes. The GameData.Core library supplies game-specific data or constants (used in bot logic), and native components like FastCall are utilized for low-level memory manipulation in the foreground scenario. These dependencies mean that regardless of which service you run, the core bot behavior and memory interface work consistently across them.
